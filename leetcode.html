<p><a href="index.html">index</a></p>
<h4 id="reviewed-leetcode-problems-for-my-personal-reference">Reviewed
LeetCode Problems (for my personal reference)</h4>
<ul>
<li><a href="https://github.com/brood0783/arai60/pull/2">brood0783 -
141. Linked List Cycle</a></li>
<li><a
href="https://github.com/chanseok-lim/arai60/pull/10">chanseok-lim -
141. Linked List Cycle</a>
<ul>
<li>When checking two objects are the same, <code>is</code> should be
used instead of <code>==</code>.</li>
</ul></li>
<li><a href="https://github.com/eito2002/LeetCode/pull/2">eito2002 -
Valid Anagram</a>
<ul>
<li>Always use if block
<ul>
<li><a
href="https://chromiumcodereview.appspot.com/10973006/diff/1/content/browser/fileapi/fileapi_message_filter.cc">Chromium
Code Reviews - Issue 10973006</a></li>
</ul></li>
<li><a
href="https://github.com/eito2002/LeetCode/pull/2#discussion_r2232818790">EBCDIC
ではアルファベットの文字コードがアルファベット順になっておらず、このコードが正しく動かないようです。ただし、
ASCII
等、近年使用されているほとんどの文字コードでは、アルファベットの文字コードがアルファベット順になっており、かつ今回の実行環境もそのようになっているので、このコードが意図通り動きます。ここまで意識できているとよいと思います。</a></li>
<li><a
href="https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement">Use
the prefix form (++i) of the increment and decrement operators unless
you need postfix semantics.</a>
<ul>
<li>“The prefix form is generally more readable, is never less
efficient, and can be more efficient because it doesn’t need to make a
copy of the value as it was before the operation.”</li>
</ul></li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/15">garunitule
- 387. First Unique Character in a String</a>
<ul>
<li>“Changed in version 3.7: Dictionary order is guaranteed to be
insertion order. This behavior was an implementation detail of CPython
from 3.6.”</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/16">garunitule
- 560. Subarray Sum Equals K</a></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/17">garunitule
- 200. Number of Islands</a>
<ul>
<li>Command Query Separation</li>
<li>Descriptive function/variable names</li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/17#discussion_r2170301165">“個人的な感覚、union
find
は現実的には多くの人が知っているし、知らなくても書かれれば読めるんですが、しかし、知らない同僚がいたとしても別に動揺しないというラインだと思いますね。”</a></li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/18">garunitule
- 695. Max Area of Island</a></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/19">garunitule
- 323. Number of Connected Components in an Undirected Graph</a>
<ul>
<li>To avoid
<code>RecursionError: maximum recursion depth exceeded while pickling an object.</code>,
it makes sense to create a stack myself to perform DFS.</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/21">garunitule
- 104. Maximum Depth of Binary Tree</a>
<ul>
<li>Cyclomatic Complexity, great engineers always come up with a very
simple solution</li>
<li>Top down vs Bottom up</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/20">garunitule
- 127. Word Ladder</a>
<ul>
<li>Shortest path -&gt; BFS</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/22">garunitule
- 111. Minimum Depth of Binary Tree</a>
<ul>
<li>Search for the shallowest leaf node -&gt; BFS</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/23">garunitule
- 617. Merge Two Binary Trees</a>
<ul>
<li>bottom-up -&gt; recursive approach</li>
<li><code>copy.deepcopy()</code> can copy an entire tree that consists
of <code>TreeNode</code></li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/24">garunitule
- 108. Convert Sorted Array to Binary Search Tree</a>
<ul>
<li>Time complexity -&gt; peak memory</li>
</ul></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/25">garunitule
- 112. Path Sum</a></li>
<li><a
href="https://github.com/garunitule/coding_practice/pull/26">garunitule
- 102. Binary Tree Level Order Traversal</a></li>
<li><a href="https://github.com/h1rosaka/arai60/pull/16">h1rosaka - 49.
Group Anagrams</a></li>
<li><a
href="https://github.com/Kazuryu0907/LeetCode_Arai60/pull/1">Kazuryu0907
- 1. Two Sum</a></li>
<li><a
href="https://github.com/Kazuryu0907/LeetCode_Arai60/pull/2">Kazuryu0907
- 387. First Unique Character in a String</a></li>
<li><a
href="https://github.com/Kazuryu0907/LeetCode_Arai60/pull/4">Kazuryu0907
- 560. Subarray Sum Equals K</a></li>
<li><a href="https://github.com/plushn/SWE-Arai60/pull/11">plushn - 1.
Two Sum</a></li>
<li><a
href="https://github.com/ryosuketc/leetcode_arai60/pull/53">ryosuketc -
322. Coin Change</a>
<ul>
<li>Memoization with <code>functools.cache</code></li>
<li>Two means of dynamic programming: memoization and tabulation</li>
</ul></li>
<li><a
href="https://github.com/Ryotaro25/leetcode_first60/pull/71">Ryotaro25 -
226. Invert Binary Tree</a>
<ul>
<li>std::swap</li>
<li>Google Style Guide: Do not use using-directives (e.g., using
namespace foo)</li>
</ul></li>
<li><a
href="https://github.com/shintaroyoshida20/leetcode/pull/32">shintaroyoshida20
- 217. Contains Duplicate</a>
<ul>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">MDN
- Array.prototype.sort()</a>
<ul>
<li>“The time and space complexity of the sort cannot be guaranteed as
it depends on the implementation.”</li>
</ul></li>
</ul></li>
<li><a
href="https://github.com/skypenguins/coding-practice/pull/19">skypenguins
- 206. Reverse Linked List</a></li>
<li><a href="https://github.com/tokuhirat/LeetCode/pull/40">tokuhirat -
322. Coin Change</a>
<ul>
<li>TIL: <code>math.isinf()</code></li>
</ul></li>
<li><a href="https://github.com/tshimosake/arai60/pull/18">tshimosake -
98. Validate Binary Search Tree</a>
<ul>
<li>BST in-order traversal -&gt; ascending (or correctly ordered)
numbers</li>
</ul></li>
</ul>
