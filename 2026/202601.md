<head><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><meta charset="UTF-8"></head>

# 20260109

- full-time job
- LeetCode 617\. Merge Two Binary Trees
	- code review (newline at the end of file, the scope of helper function, Command-query separation)
- LeetCode 1\. Two Sum
	- code review (big O notation)
- Hinodeya Ramen and Dr. Ink w/ my wife
- LeetCode 200\. Number of Islands
- LeetCode 207\. Course Schedule
- LeetCode 133\. Clone Graph
	- I was surprised I could reproduce solutions for 207 and 133. It is good.
- 30 minutes walk
- LeetCode 200\. Number of Islands
	- PR: [https://github.com/huyfififi/coding-challenges/pull/40](https://github.com/huyfififi/coding-challenges/pull/40)
- 30 minutes run

# 20260108

- full-time job
- LeetCode 373\. Find K Pairs with Smallest Sum
	- tried myself
	- code review
	- There are two approaches
		- starting from (i, 0), check (index1, index2 + 1)
		- starting from (0, 0), check (index1 + 1) and (index1, index2 + 1)
- 30 minutes walk
- 30 minutes walk + English conversation with ChatGPT
- LeetCode 98\. Validate Binary Search Tree
	- PR: [https://github.com/huyfififi/coding-challenges/pull/39](https://github.com/huyfififi/coding-challenges/pull/39)

```373_start_from_min.py
import heapq


class Solution:
    def kSmallestPairs(
        self, nums1: list[int], nums2: list[int], k: int
    ) -> list[list[int]]:
        sum_and_pairs: list[tuple[int, tuple[int, int]]] = [
            (nums1[0] + nums2[0], (0, 0))
        ]
        checked_pairs: set[tuple[int, int]] = set()
        smallest_pairs: list[list[int]] = []
        while sum_and_pairs and len(smallest_pairs) < k:
            index1, index2 = heapq.heappop(sum_and_pairs)[1]
            if (index1, index2) in checked_pairs:
                continue

            smallest_pairs.append([nums1[index1], nums2[index2]])
            checked_pairs.add((index1, index2))

            if index1 + 1 < len(nums1):
                heapq.heappush(
                    sum_and_pairs,
                    (nums1[index1 + 1] + nums2[index2], (index1 + 1, index2)),
                )
            if index2 + 1 < len(nums2):
                heapq.heappush(
                    sum_and_pairs,
                    (nums1[index1] + nums2[index2 + 1], (index1, index2 + 1)),
                )

        return smallest_pairs
```

```373_start_from_nums1.py
import heapq


class Solution:
    def kSmallestPairs(
        self, nums1: list[int], nums2: list[int], k: int
    ) -> list[list[int]]:
        sum_and_pairs = []
        for i in range(len(nums1)):
            heapq.heappush(sum_and_pairs, (nums1[i] + nums2[0], (i, 0)))

        smallest_pairs = []
        while sum_and_pairs and len(smallest_pairs) < k:
            index1, index2 = heapq.heappop(sum_and_pairs)[1]
            smallest_pairs.append([nums1[index1], nums2[index2]])

            if index2 + 1 < len(nums2):
                heapq.heappush(
                    sum_and_pairs,
                    (nums1[index1] + nums2[index2 + 1], (index1, index2 + 1)),
                )

        return smallest_pairs
```

# 20260107

- full-time job
- reviewed English words I noted yesterday
	- engross, induce, condone, innocuous, vagary, sate
- squat, push ups
- The Technological Republic
	- supersede, fetter, unfettered, corporeal
- LeetCode 238\. Product of Array Except Self
	- checked review comments by Noda-san
		- `rbegin()`, `rend()`
		- `std::partial_sum()` in `numeric`
		- `std::multiplies` is in `functional`
- LeetCode 347\. Top K Frequent Elements
	- tried heap and sort
	- code review
- LeetCode 155\. Min Stack
	- PR: [https://github.com/huyfififi/coding-challenges/pull/38](https://github.com/huyfififi/coding-challenges/pull/38)
- push ups, 20 minutes run

# 20260106

- LeetCode 322\. Coin Change
	- left comments on my own PR, discussing the program's processing time
- LeetCode 104\. Maximum Depth of Binary Tree
	- code review (time/space complexity, simpler condition branching)
- push ups
- full-time job
- Barron's Essential Words for the TOEFL
	- worthwhile, ascertain, designate. brash, engross, precipitate, oblivious, encompass, inundate, impartial, appallingly, brazen, induce, teem (be teeming with), potent, apt (appropriate, be apt to), aggravate
- The Technological Republic
	- ascendant, condone, innocuous, vagary, sate
- 50 minutes walk + English conversation with ChatGPT
- LeetCode 238\. Product of Array Except Self
- 25 minutes run

# 20260105

- full-time job
	- checked all the updates while I was away
	- did some bug fixes
- LeetCode 703\. Kth Largest Element in a Stream
	- code review (name mismatch between a constructor and functions)
	- `for (auto it : num_to_count) {` iterating `std::map` -> `it.first`, `it.second`
- 1 hour walk / English conversation with ChatGPT
- LeetCode 322\. Coin Change
	- tabulation / memoization
	- PR: [https://github.com/huyfififi/coding-challenges/pull/36](https://github.com/huyfififi/coding-challenges/pull/36)

# 20260104

- replied to Nishimura-san
- LeetCode 206. Reverse Linked List
	- code review (variable names do not reflect their values/meanings)
	- it was unexpectedly hard to write the solution...
- replied to Noda-san's comment
- LeetCode 207\. Course Schedule (Kahn's algorithm, DFS)
- LeetCode 208\. Implement Trie
	- C++ memory leak (free memory or use `std::unique_ptr` / `std::shared_ptr`)
	- PR: [https://github.com/huyfififi/coding-challenges/pull/35](https://github.com/huyfififi/coding-challenges/pull/35)
- sorted out Dependabot PRs (full-time position)
- 30 minutes jog

# 20260103

- LeetCode 20\. Valid Parentheses
	- checked review comments
		- std::stack.empty() over std::stack.size() == 0
		- for historical reasons, when writing if condition, "...curly braces may be omitted if as a result the entire statement appears on either a single line")
- LeetCode 207\. Course Schedule
	- checked review comments
		- received feedback from Noda-san here: [https://github.com/huyfififi/coding-challenges/pull/34](https://github.com/huyfififi/coding-challenges/pull/34)
		- I was forgetting that dict keys can be traversed without `dict.keys()`
		- C++: array cannot be created with a size that depends on run time execution
		- retried Kahn's algorithm
		- tackled the vector-based approach (replace `std::set` -> `std::vector` by defining num class constants)
	- LeetCode went down :sweat:
- 30 minutes walk, push ups
- leetCode 21\. Merge Two Sorted Lists
	- "Use values to own data, pointers to traverse linked structures, and references to alias a specific object." by ChatGPT
	- `list1` -> address of node, `*list1` -> the node itself
	- Every new must have a corresponding delete.
- LeetCode 122\. Best Time to Buy and Sell Stock II
	- 1 -> 5 is equivalent to 1 -> 3 and 3 -> 5 (greedy)
	- complicated DP

```cpp
#include <algorithm>
#include <vector>

class Solution {
public:
    int maxProfit(std::vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); ++i) {
            profit += std::max(0, prices[i] - prices[i - 1]);
        }
        return profit;
    }
};
```

# 20260102

- LeetCode 207\. Course Schedule
	- A closure = a function + the variables it captures from outside
	- in most cases, simple DFS or BFS is enough
		- English grammar: A or B â†’ verb agrees with the nearest subject
	- DFS
	- Kahn's algorithm (BFS)
	- PR: [https://github.com/huyfififi/coding-challenges/pull/34](https://github.com/huyfififi/coding-challenges/pull/34)
- LeetCode 20\. Valid Parentheses
	- code review (dangling else, No newline at end of file, return bool, map variable name)
- 30 minutes jog

# 20260101

- LeetCode 1. Two Sum
	- double for loops
	- std::map
	- std::sort, auto [variable1, variable 2]
	- std::vector can be passed by value in addition to by reference, but the most common pattern is const + reference as it can block modifications + eliminate the need of copying values
- The Technological Republic
	- spur, spurn, untangle, disentangle, electorate, unmoored, abandonment, textile
- Computer Organization and Design
	- SPEC (System Performance Evaluation Cooperative)
		- non-profit organization that creates standardized benchmarks to measure and compare computer system performance in a fair, reproducible way
		- [*The SPEC CPUÂ® 2017 benchmark benchmark package contains SPEC's next-generation, industry-standardized, CPU intensive suites for measuring and comparing compute intensive performance, stressing a system's processor, memory subsystem and compiler.*](https://www.spec.org/cpu2017/)
- LeetCode 207. Course Schedule
	- remembering topological sort
- replied to some work-related messages
- push ups, 40 minutes jog

---

TODO:

- dentist's appointment (20260217 11:30 am)

---

[index](../index.html)
[202512](../2025/202512.html)
[202602](202602.html)
