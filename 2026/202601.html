<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta charset="UTF-8">
</head>
<h1 id="section">20260114</h1>
<ul>
<li>full-time job</li>
<li>LeetCode
<ul>
<li>46. Permutations</li>
</ul></li>
</ul>
<h1 id="section-1">20260113</h1>
<ul>
<li>40 minutes walk, push ups, 30 minutes run</li>
<li>full-time job</li>
<li>LeetCode 39. Combination Sum
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/43">https://github.com/huyfififi/coding-challenges/pull/43</a></li>
</ul></li>
<li>LeetCode 46. Permutations
<ul>
<li>Classic problem but it is hard to reason time/space complexity</li>
</ul></li>
<li>LeetCode 560. Subarray Sum Equals K (code review)
<ul>
<li>TIL: one way hash map solution</li>
</ul></li>
<li>scheduled appointments</li>
</ul>
<h1 id="section-2">20260112</h1>
<p><code>grep -E '^- \[.*\]\(https://github.com/.*/pull/[0-9]+\)' leetcode.md | wc -l</code></p>
<ul>
<li>LeetCode 929. Unique Email Addresses (code review)
<ul>
<li><code>std::string::substr</code>, <code>std::string::erase</code>,
<code>std::set::emplace</code></li>
</ul></li>
<li>LeetCode 112. Path Sum (code review)</li>
<li>full-time job</li>
<li>30 minutes walk</li>
<li>LeetCode 98. Validate Binary Search Tree (code review)</li>
<li>The Technological Republic
<ul>
<li>rudder, supersede, opaque, prod, pointy, maturation, quintessential,
plausible</li>
</ul></li>
<li>40 minutes walk + English conversation with ChatGPT</li>
<li>LeetCode 39. Combination Sum</li>
<li>LeetCode 387. First Unique Character in a String (code review)</li>
</ul>
<h1 id="section-3">20260111</h1>
<p>I was thinking about just chilling today, but I ended up doing many
household chores and studying hard.</p>
<ul>
<li>30 minutes walk</li>
<li>LeetCode 349. Intersection of Two Arrays (code review)
<ul>
<li>pruning elements to reduce the number of loops</li>
</ul></li>
<li>LeetCode 108. Convert Sorted Array to Binary Search Tree (code
review)</li>
<li>LeetCode 33. Search in Rotated Sorted Array
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/42">https://github.com/huyfififi/coding-challenges/pull/42</a></li>
</ul></li>
<li>40 minutes run</li>
</ul>
<h1 id="section-4">20260110</h1>
<ul>
<li>LeetCode 49. Group Anagrams
<ul>
<li>code review (TIL: <code>std::move</code>)</li>
</ul></li>
<li>LeetCode 994. Rotting Oranges
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/41">https://github.com/huyfififi/coding-challenges/pull/41</a></li>
</ul></li>
<li>40 minutes walk + English conversation with ChatGPT</li>
<li>LeetCode Weekly Contest 484</li>
<li>push ups, 40 minutes walk</li>
</ul>
<h1 id="section-5">20260109</h1>
<ul>
<li>full-time job</li>
<li>LeetCode 617. Merge Two Binary Trees
<ul>
<li>code review (newline at the end of file, the scope of helper
function, Command-query separation)</li>
</ul></li>
<li>LeetCode 1. Two Sum
<ul>
<li>code review (big O notation)</li>
</ul></li>
<li>Hinodeya Ramen and Dr. Ink w/ my wife</li>
<li>LeetCode 200. Number of Islands</li>
<li>LeetCode 207. Course Schedule</li>
<li>LeetCode 133. Clone Graph
<ul>
<li>I was surprised I could reproduce solutions for 207 and 133. It is
good.</li>
</ul></li>
<li>30 minutes walk</li>
<li>LeetCode 200. Number of Islands
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/40">https://github.com/huyfififi/coding-challenges/pull/40</a></li>
</ul></li>
<li>30 minutes run</li>
</ul>
<h1 id="section-6">20260108</h1>
<ul>
<li>full-time job</li>
<li>LeetCode 373. Find K Pairs with Smallest Sum
<ul>
<li>tried myself</li>
<li>code review</li>
<li>There are two approaches
<ul>
<li>starting from (i, 0), check (index1, index2 + 1)</li>
<li>starting from (0, 0), check (index1 + 1) and (index1, index2 +
1)</li>
</ul></li>
</ul></li>
<li>30 minutes walk</li>
<li>30 minutes walk + English conversation with ChatGPT</li>
<li>LeetCode 98. Validate Binary Search Tree
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/39">https://github.com/huyfififi/coding-challenges/pull/39</a></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb1"><pre
class="sourceCode 373_start_from_min.py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> kSmallestPairs(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>, nums1: <span class="bu">list</span>[<span class="bu">int</span>], nums2: <span class="bu">list</span>[<span class="bu">int</span>], k: <span class="bu">int</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        sum_and_pairs: <span class="bu">list</span>[<span class="bu">tuple</span>[<span class="bu">int</span>, <span class="bu">tuple</span>[<span class="bu">int</span>, <span class="bu">int</span>]]] <span class="op">=</span> [</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            (nums1[<span class="dv">0</span>] <span class="op">+</span> nums2[<span class="dv">0</span>], (<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        checked_pairs: <span class="bu">set</span>[<span class="bu">tuple</span>[<span class="bu">int</span>, <span class="bu">int</span>]] <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        smallest_pairs: <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]] <span class="op">=</span> []</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> sum_and_pairs <span class="kw">and</span> <span class="bu">len</span>(smallest_pairs) <span class="op">&lt;</span> k:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            index1, index2 <span class="op">=</span> heapq.heappop(sum_and_pairs)[<span class="dv">1</span>]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (index1, index2) <span class="kw">in</span> checked_pairs:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            smallest_pairs.append([nums1[index1], nums2[index2]])</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            checked_pairs.add((index1, index2))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> index1 <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(nums1):</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                    sum_and_pairs,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                    (nums1[index1 <span class="op">+</span> <span class="dv">1</span>] <span class="op">+</span> nums2[index2], (index1 <span class="op">+</span> <span class="dv">1</span>, index2)),</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> index2 <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(nums2):</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                    sum_and_pairs,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                    (nums1[index1] <span class="op">+</span> nums2[index2 <span class="op">+</span> <span class="dv">1</span>], (index1, index2 <span class="op">+</span> <span class="dv">1</span>)),</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> smallest_pairs</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode 373_start_from_nums1.py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> kSmallestPairs(</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>, nums1: <span class="bu">list</span>[<span class="bu">int</span>], nums2: <span class="bu">list</span>[<span class="bu">int</span>], k: <span class="bu">int</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        sum_and_pairs <span class="op">=</span> []</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nums1)):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            heapq.heappush(sum_and_pairs, (nums1[i] <span class="op">+</span> nums2[<span class="dv">0</span>], (i, <span class="dv">0</span>)))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        smallest_pairs <span class="op">=</span> []</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> sum_and_pairs <span class="kw">and</span> <span class="bu">len</span>(smallest_pairs) <span class="op">&lt;</span> k:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            index1, index2 <span class="op">=</span> heapq.heappop(sum_and_pairs)[<span class="dv">1</span>]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            smallest_pairs.append([nums1[index1], nums2[index2]])</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> index2 <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> <span class="bu">len</span>(nums2):</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                heapq.heappush(</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                    sum_and_pairs,</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                    (nums1[index1] <span class="op">+</span> nums2[index2 <span class="op">+</span> <span class="dv">1</span>], (index1, index2 <span class="op">+</span> <span class="dv">1</span>)),</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> smallest_pairs</span></code></pre></div>
<h1 id="section-7">20260107</h1>
<ul>
<li>full-time job</li>
<li>reviewed English words I noted yesterday
<ul>
<li>engross, induce, condone, innocuous, vagary, sate</li>
</ul></li>
<li>squat, push ups</li>
<li>The Technological Republic
<ul>
<li>supersede, fetter, unfettered, corporeal</li>
</ul></li>
<li>LeetCode 238. Product of Array Except Self
<ul>
<li>checked review comments by Noda-san
<ul>
<li><code>rbegin()</code>, <code>rend()</code></li>
<li><code>std::partial_sum()</code> in <code>numeric</code></li>
<li><code>std::multiplies</code> is in <code>functional</code></li>
</ul></li>
</ul></li>
<li>LeetCode 347. Top K Frequent Elements
<ul>
<li>tried heap and sort</li>
<li>code review</li>
</ul></li>
<li>LeetCode 155. Min Stack
<ul>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/38">https://github.com/huyfififi/coding-challenges/pull/38</a></li>
</ul></li>
<li>push ups, 20 minutes run</li>
</ul>
<h1 id="section-8">20260106</h1>
<ul>
<li>LeetCode 322. Coin Change
<ul>
<li>left comments on my own PR, discussing the program’s processing
time</li>
</ul></li>
<li>LeetCode 104. Maximum Depth of Binary Tree
<ul>
<li>code review (time/space complexity, simpler condition
branching)</li>
</ul></li>
<li>push ups</li>
<li>full-time job</li>
<li>Barron’s Essential Words for the TOEFL
<ul>
<li>worthwhile, ascertain, designate. brash, engross, precipitate,
oblivious, encompass, inundate, impartial, appallingly, brazen, induce,
teem (be teeming with), potent, apt (appropriate, be apt to),
aggravate</li>
</ul></li>
<li>The Technological Republic
<ul>
<li>ascendant, condone, innocuous, vagary, sate</li>
</ul></li>
<li>50 minutes walk + English conversation with ChatGPT</li>
<li>LeetCode 238. Product of Array Except Self</li>
<li>25 minutes run</li>
</ul>
<h1 id="section-9">20260105</h1>
<ul>
<li>full-time job
<ul>
<li>checked all the updates while I was away</li>
<li>did some bug fixes</li>
</ul></li>
<li>LeetCode 703. Kth Largest Element in a Stream
<ul>
<li>code review (name mismatch between a constructor and functions)</li>
<li><code>for (auto it : num_to_count) {</code> iterating
<code>std::map</code> -&gt; <code>it.first</code>,
<code>it.second</code></li>
</ul></li>
<li>1 hour walk / English conversation with ChatGPT</li>
<li>LeetCode 322. Coin Change
<ul>
<li>tabulation / memoization</li>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/36">https://github.com/huyfififi/coding-challenges/pull/36</a></li>
</ul></li>
</ul>
<h1 id="section-10">20260104</h1>
<ul>
<li>replied to Nishimura-san</li>
<li>LeetCode 206. Reverse Linked List
<ul>
<li>code review (variable names do not reflect their
values/meanings)</li>
<li>it was unexpectedly hard to write the solution…</li>
</ul></li>
<li>replied to Noda-san’s comment</li>
<li>LeetCode 207. Course Schedule (Kahn’s algorithm, DFS)</li>
<li>LeetCode 208. Implement Trie
<ul>
<li>C++ memory leak (free memory or use <code>std::unique_ptr</code> /
<code>std::shared_ptr</code>)</li>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/35">https://github.com/huyfififi/coding-challenges/pull/35</a></li>
</ul></li>
<li>sorted out Dependabot PRs (full-time position)</li>
<li>30 minutes jog</li>
</ul>
<h1 id="section-11">20260103</h1>
<ul>
<li>LeetCode 20. Valid Parentheses
<ul>
<li>checked review comments
<ul>
<li>std::stack.empty() over std::stack.size() == 0</li>
<li>for historical reasons, when writing if condition, “…curly braces
may be omitted if as a result the entire statement appears on either a
single line”)</li>
</ul></li>
</ul></li>
<li>LeetCode 207. Course Schedule
<ul>
<li>checked review comments
<ul>
<li>received feedback from Noda-san here: <a
href="https://github.com/huyfififi/coding-challenges/pull/34">https://github.com/huyfififi/coding-challenges/pull/34</a></li>
<li>I was forgetting that dict keys can be traversed without
<code>dict.keys()</code></li>
<li>C++: array cannot be created with a size that depends on run time
execution</li>
<li>retried Kahn’s algorithm</li>
<li>tackled the vector-based approach (replace <code>std::set</code>
-&gt; <code>std::vector</code> by defining num class constants)</li>
</ul></li>
<li>LeetCode went down :sweat:</li>
</ul></li>
<li>30 minutes walk, push ups</li>
<li>leetCode 21. Merge Two Sorted Lists
<ul>
<li>“Use values to own data, pointers to traverse linked structures, and
references to alias a specific object.” by ChatGPT</li>
<li><code>list1</code> -&gt; address of node, <code>*list1</code> -&gt;
the node itself</li>
<li>Every new must have a corresponding delete.</li>
</ul></li>
<li>LeetCode 122. Best Time to Buy and Sell Stock II
<ul>
<li>1 -&gt; 5 is equivalent to 1 -&gt; 3 and 3 -&gt; 5 (greedy)</li>
<li>complicated DP</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> prices<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> profit <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> prices<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            profit <span class="op">+=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> prices<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> prices<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> profit<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h1 id="section-12">20260102</h1>
<ul>
<li>LeetCode 207. Course Schedule
<ul>
<li>A closure = a function + the variables it captures from outside</li>
<li>in most cases, simple DFS or BFS is enough
<ul>
<li>English grammar: A or B → verb agrees with the nearest subject</li>
</ul></li>
<li>DFS</li>
<li>Kahn’s algorithm (BFS)</li>
<li>PR: <a
href="https://github.com/huyfififi/coding-challenges/pull/34">https://github.com/huyfififi/coding-challenges/pull/34</a></li>
</ul></li>
<li>LeetCode 20. Valid Parentheses
<ul>
<li>code review (dangling else, No newline at end of file, return bool,
map variable name)</li>
</ul></li>
<li>30 minutes jog</li>
</ul>
<h1 id="section-13">20260101</h1>
<ul>
<li>LeetCode 1. Two Sum
<ul>
<li>double for loops</li>
<li>std::map</li>
<li>std::sort, auto [variable1, variable 2]</li>
<li>std::vector can be passed by value in addition to by reference, but
the most common pattern is const + reference as it can block
modifications + eliminate the need of copying values</li>
</ul></li>
<li>The Technological Republic
<ul>
<li>spur, spurn, untangle, disentangle, electorate, unmoored,
abandonment, textile</li>
</ul></li>
<li>Computer Organization and Design
<ul>
<li>SPEC (System Performance Evaluation Cooperative)
<ul>
<li>non-profit organization that creates standardized benchmarks to
measure and compare computer system performance in a fair, reproducible
way</li>
<li><a href="https://www.spec.org/cpu2017/"><em>The SPEC CPU® 2017
benchmark benchmark package contains SPEC’s next-generation,
industry-standardized, CPU intensive suites for measuring and comparing
compute intensive performance, stressing a system’s processor, memory
subsystem and compiler.</em></a></li>
</ul></li>
</ul></li>
<li>LeetCode 207. Course Schedule
<ul>
<li>remembering topological sort</li>
</ul></li>
<li>replied to some work-related messages</li>
<li>push ups, 40 minutes jog</li>
</ul>
<hr />
<p>TODO:</p>
<ul>
<li>cancel Farmer’s insurance (20260120)</li>
<li>dentist’s appointment (20260217 11:30 am)</li>
</ul>
<hr />
<p><a href="../index.html">index</a> <a
href="../2025/202512.html">202512</a> <a
href="202602.html">202602</a></p>
