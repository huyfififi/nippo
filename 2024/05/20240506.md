<head><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /></head>

# 20240506

## npm: installing a package globally

I was reviewing a Git repository of a frontend project and encountered a package used in code but not appear in `package.json` or `package-lock.json`.

It turned out that the package is expected to be installed globally. Globally installed packages are accessible from anywhere on my system, but they wouldn\'t be listed as dependencies in my project\'s package.json.

`package.json` (and `package-lock.json`) should be self-sufficient to allow new team members to run the project immediately, and having complete `package(-lock).json` also makes the deployment of the service easy.

IMO, global package installation should be avoided

## bufio

- func (s \*Scanner) Scan() bool
	- Scan advances the Scanner to the next token, \.\.\.
- func (s \*Scanner) Text() string
	- Text returns the most recent token generated by a call to Scanner.Scan as a newly allocated string holding its bytes.

The combination of these methods might be the way to read a line repeatedly.

## [1380A. Three indices]()

### O(n^3) brute-force (time limit exceeded, just for reference)

3 <= n <= 1000 -> n^3 <= 10^9 -> TLE

```
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)

	scanner.Scan()
	t, _ := strconv.Atoi(scanner.Text())

	for tc := 0; tc < t; tc++ {
		scanner.Scan()
		n, _ := strconv.Atoi(scanner.Text())

		scanner.Scan()
		p := make([]int, n)
		for j, numStr := range strings.Split(scanner.Text(), " ") {
			num, _ := strconv.Atoi(numStr)
			p[j] = num
		}
		found := false
		for i := 0; i < n-2; i++ {
			if found {
				break
			}
			for j := i + 1; j < n-1; j++ {
				if found {
					break
				}
				for k := j + 1; k < n; k++ {
					if p[j] > p[i] && p[j] > p[k] {
						fmt.Println("YES")
						fmt.Println(i+1, j+1, k+1)
						found = true
						break
					}
				}
			}
		}
		if found != true {
			fmt.Println("NO")
		}
	}
}
```

### O(n^2)

Iterate on j and find i by decreasing index starting from j - 1 and find k by increasing index starting from j + 1. 

- Iteration on j -> O(n)
- the total pointer movement to check i and k -> O(n)
- -> O(n^2)

```
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)

	scanner.Scan()
	t, _ := strconv.Atoi(scanner.Text())

	for tc := 0; tc < t; tc++ {
		scanner.Scan()
		n, _ := strconv.Atoi(scanner.Text())

		scanner.Scan()
		p := make([]int, n)
		for pi, numStr := range strings.Split(scanner.Text(), " ") {
			num, _ := strconv.Atoi(numStr)
			p[pi] = num
		}

		found := false
		for j := 1; j < n-1; j++ {
			i := j
			for ; i >= 0; i-- {
				if p[i] < p[j] {
					break
				}
			}
			if i == -1 {
				continue
			}

			k := j + 1
			for ; k < n; k++ {
				if p[j] > p[k] {
					break
				}
			}
			if k == n {
				continue
			}

			found = true
			fmt.Println("YES")
			fmt.Println(i+1, j+1, k+1)
			break
		}
		if found {
			continue
		}
		fmt.Println("NO")
	}
}
```

### O(n)

[Editorial](https://codeforces.com/blog/entry/80054)

I couldn\'t understnad the solution. I\'ll think about it again later. Maybe it\'s helpful to find YouTube videos about the problem.

---

Jane Street suddenly released a trading game

[https://www.linkedin.com/posts/jane-street-global_download-the-new-figgie-app-activity-7193325193329623040-efrv?utm_source=share&utm_medium=member_desktop](https://www.linkedin.com/posts/jane-street-global_download-the-new-figgie-app-activity-7193325193329623040-efrv?utm_source=share&utm_medium=member_desktop)

---

Teriyaki Madness 1500
Caffe Latte 200
Bubble tea 600

Total 2300 kcal

---

[index](../../index.html)
[20240505](20240505.html)
[20240507](20240507.html)
