<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta charset="UTF-8">
</head>
<h1 id="section">20240725</h1>
<ul>
<li>Solved 2 problem.</li>
<li>Set an alarm for tomorrow.</li>
<li>Guided my friend on how to configure GitHub Actions</li>
</ul>
<h2 id="d.-manhattan-circle"><a
href="https://codeforces.com/problemset/problem/1985/D">1985D. Manhattan
Circle</a></h2>
<pre><code>from typing import Optional


def solve(n: int, m: int, mat: list[list[str]]) -&gt; tuple[int, int]:
    longest_rowi: int = -1
    longest_len: int = 0

    for rowi in range(n):
        manlen: int = sum(1 if x == &quot;#&quot; else 0 for x in mat[rowi])
        if manlen &gt; longest_len:
            longest_len = manlen
            longest_rowi = rowi

    li: Optional[int] = None
    ri: Optional[int] = None
    for coli in range(m):
        if mat[longest_rowi][coli] != &quot;#&quot;:
            continue
        if li is None:
            li = coli
        ri = coli

    # because of the nature of Manhattan circle, `ri + li` is always even
    midi = (ri + li) // 2
    return longest_rowi + 1, midi + 1


for _ in range(int(input())):
    n, m = map(int, input().split())
    mat = []
    for i in range(n):
        mat.append(list(input()))

    res: tuple[int, int] = solve(n, m, mat)
    print(f&quot;{res[0]} {res[1]}&quot;)</code></pre>
<h2 id="c.-good-prefixes"><a
href="https://codeforces.com/problemset/problem/1985/C">1985C. Good
Prefixes</a></h2>
<p><code>t &lt;= 10 ^ 4</code> and <code>n &lt;= 2 * 10 ^ 5</code>, so I
needed to come up with a <code>O(n)</code> solution.</p>
<p>I thought of an approach that checks <code>sum // 2 in prefix</code>
using <code>set</code> or <code>dict</code>, so that the check should be
doen in <code>O(1)</code> and <code>O(n)</code> in total.</p>
<p>However, that approach exceeded the time limit on test 10. My
suspicion is that, the number of elements I needed to hold in a hash
table was too large, facing collisions, and the time complexity of the
lookup became &gt; <code>O(1)</code> (~=<code>O(n)</code>?), making the
total time complexity exceed <code>O(n)</code>.</p>
<p>The fact I could not notice is that I only need to track the maximum
number in a prefix because only the maximum number in a prefix can be
<code>sum // 2</code>. Other values cannot be satisfy the condition
because the remaining part already contains a value bigger than the
value, thus the value is always smaller than the sum, including the
maximum element.</p>
<pre><code>from collections import defaultdict


def solve(n: int, a: list[int]) -&gt; int:
    su: int = 0
    ma: int = 0
    ans: int = 0
    for x in a:
        su += x
        ma = max(ma, x)
        if ma * 2 == su:
            ans += 1
    return ans


for _ in range(int(input())):
    n: int = int(input())
    a: list[int] = list(map(int, input().split()))
    ans: int = solve(n, a)
    print(ans)</code></pre>
<hr />
<p>Ketone 40 mg/dl // I'm taking Keto suppliments, and I bet the Keto is
not something generated by my body.</p>
<p>Bacon Egg 0g Salad 20g Pistachio 10g Protein shake 10g</p>
<p>Total carbohydrate 40g</p>
<hr />
<p>MUST:</p>
<ul>
<li>Solve 2 problems.</li>
<li>Review 1 problem.</li>
<li>Create my first pull request in <code>cyclon</code>, updating a
function with Result&lt;&gt; (20240728)</li>
</ul>
<p>TODO:</p>
<ul>
<li>Update my resume with the sign up feature</li>
<li>Update my resume with the document structure and AWS S3</li>
<li>Update my LinkedIn summary section</li>
<li>Consider the microservice independency with Redis/RabbitMQ</li>
<li>Clean my keyboard</li>
</ul>
<hr />
<p><a href="../../index.html">index</a> <a
href="20240724.html">20240724</a> <a
href="20240726.html">20240726</a></p>
