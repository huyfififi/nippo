<head><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /><meta charset="UTF-8"></head>

# 20240826

- Visited the Consulate-General of Japan in San Francisco to receive the updated passport.
	- It takes more than one hour to drive to San Francisco, and now I\i'm tired from the long drive.
	- Parking lots in San Francisco are very expensive.
	- I hate the atomosphere of San Francisco.
	- The town is dirty and smells awful. There are many shady people.
	- Watched sea lions.
- Replied back to a mentee about unit/end-to-end testing

## [2003A. Turtle and Good Strings - 800](https://codeforces.com/contest/2003/problem/A)

### My idea

`k = 2` is the simplest scenario, and if it\'s impossible with `k = 2`, it\'s also impossible with `k >= 3`.

When we think about `k = 3`, the first character of `t1` must be different from last characters of `t2` and `t3`, but the condition is more strict than thinking about only `t1` v.s. `t2`. Therefore, I only consider `k = 2` for simplicity\'s sake. (not very confident about the explanation).

When `k = 2`, we just have to check if there is a pair of `(t1, t2)` where `t1[0] != t2[-1] and t1[-1] != t2[0]`.

```
def possible(n: int, s: list[str]) -> bool:
    for i in range(n - 1):
        if s[i] != s[i + 1]:
            return s[0] != s[n - 1]
    return False


for _ in range(int(input())):
    n: int = int(input())
    s: list[str] = list(input())
    if possible(n, s):
        print("YES")
    else:
        print("NO")
```

### The answer from the editorial

[Codeforces Round 968 (Div. 2) Editorial](https://codeforces.com/blog/entry/132953)

> A necessary condition for `s` to be good is that `s1 != sn`.

> For a string `s` where `s1 != sn`, let `t1` be a string composed of just the simple character `s1`, and let `t2` be a string composed of the `n - 1` characters from `s2` to `sn`.

> In this way, the condition is satisfied.

> Therefore, if `s1` != `sn`, the answer is "Yes"; otherwise, the answer is "No".

I misunderstood the problem. I thought `t2`\'s first character must not be equal to `t1`\'s last character, but the condition is

> For all `1 <= i < j <= k`, the first character of `ti` isn\'t equal to the last character of `tj`. We only have to compare the first character of `ti` with the last characters of strings come after `ti`.

The answer is as simple as

```
for _ in range(int(input())):
    n: int = int(input())
    s: str = input()
    if s[0] != s[-1]:
        print("YES")
    else:
        print("NO")
```

---

Rice 400
Meat and Potatos 500
Protein bars 400
Protein shake 200
Salad 400
Yogurt 200

Total 2100 kcal

10k walking

---

MUST:

- None

TODO:

- Review Codeforces 2003B
- Check the editorial of 1884B
- Self-guided tour, 20240914 3:00 pm

---

[index](../../index.html)
[20240825](20240825.html)
[20240827](20240827.html)
